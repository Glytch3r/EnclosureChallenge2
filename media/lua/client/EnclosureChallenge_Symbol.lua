--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

require "lua_timers"
EnclosureChallenge = EnclosureChallenge or {}


function EnclosureChallenge.addMapSymbol(x, y, tex)
    if not ISWorldMap_instance then
        ISWorldMap.ShowWorldMap(0)
        ISWorldMap_instance:close()
    end
    local sq = getCell():getOrCreateGridSquare(x, y, 0)
    local isConquered = EnclosureChallenge.isConquered(sq)
	local mapAPI = ISWorldMap_instance.javaObject:getAPIv1()
	local symAPI = mapAPI:getSymbolsAPI()
	local sym = symAPI:addTexture(tex, x, y)
	sym:setAnchor(0.5, 0.5)


    sym:setAnchor(0.5, 0.5)
    local colStr = SandboxVars.EnclosureChallengeGUI.BadColor
    if isConquered and colStr then
        colStr = SandboxVars.EnclosureChallengeGUI.GoodColor
    end

    local col = EnclosureChallenge.parseColor(colStr)
    sym:setRGBA(col.r, col.g, col.b, col.a)

end

function EnclosureChallenge.isEncSym(symName)
    local tab = {
        ["Enclosure_Conquered"]=true,
        ["Enclosure_Challenge"]=true,
        ["X"]=true,

    }
    return tab[tostring(symName)]
end

function EnclosureChallenge.delSym(x, y)
	if not ISWorldMap_instance then return end
	if not x or not y then return end

	local mapAPI = ISWorldMap_instance.javaObject:getAPIv1()
	local symAPI = mapAPI:getSymbolsAPI()

	for i = symAPI:getSymbolCount() - 1, 0, -1 do
		local sym = symAPI:getSymbolByIndex(i)
		--if sym:getWorldX() == x and sym:getWorldY() == y and sym:getTextureName() == textureName then
		if sym:getWorldX() == x and sym:getWorldY() == y then
            symAPI:removeSymbolByIndex(i)
		end
	end
end
-----------------------


function EnclosureChallenge.addChallengeSymbols(targ)
	if not ISWorldMap_instance then
		ISWorldMap.ShowWorldMap(0)
		if ISWorldMap_instance then ISWorldMap_instance:close() end
	end
	if not ISWorldMap_instance or not ISWorldMap_instance.javaObject then return end

    local pl = getPlayer();
    if not pl then return end
    targ = targ or pl
    if not targ then return end

	--local encStr = EnclosureChallenge.getEnclosureStr(targ)
	local status = EnclosureChallenge.getEnclosureStatus(targ)
	if not status then return end
    local stampMap = {
        ["Conquered"] = "Enclosure_Conquered",
        ["Unlocked"]  = "Enclosure_Challenge",
        ["Neutral"]   = nil,
    }
    local stamp = stampMap[status]
    if not stamp then return end
    local x = targ:getX()
    local y = targ:getY()
    local  midX, midY = EnclosureChallenge.getEnclosureMidXY(x, y, targ)

    EnclosureChallenge.addMapSymbol(midX, midY, stamp)

end
-----------------------            ---------------------------

EnclosureChallenge.ISMiniMapOuter = EnclosureChallenge.ISMiniMapOuter or ISMiniMapOuter.render
function ISMiniMapOuter:render()
    EnclosureChallenge.ISMiniMapOuter(self)
    if not ISWorldMap_instance then return end
    if not self.mapAPI then return end
    local pl = getSpecificPlayer(self.playerNum)
    local x = pl:getX()
    local y = pl:getY()
    local midX, midY = EnclosureChallenge.getEnclosureMidXY(x, y, pl)
    EnclosureChallenge.drawEnclosureGridOverlay(self, midX, midY)
end

-----------------------            ---------------------------
function EnclosureChallenge.drawEnclosureGridOverlay(minimap, midX, midY)
    local size = EnclosureChallenge.EnclosureSize or 189
    local half = math.floor(size / 2)
    local x1 = midX - half
    local x2 = midX + half
    local y1 = midY - half
    local y2 = midY + half

    local step = 10 -- grid spacing
    local col = {r=1, g=1, b=0.2, a=0.2}

    for x = x1, x2, step do
        EnclosureChallenge.drawMapLine(minimap, x, y1, x, y2, col)
    end
    for y = y1, y2, step do
        EnclosureChallenge.drawMapLine(minimap, x1, y, x2, y, col)
    end
end
function EnclosureChallenge.drawMapLine(minimap, x1, y1, x2, y2, col)
    if not minimap or not minimap.mapAPI then return end
    local sx1 = minimap.mapAPI:worldToUIX(x1)
    local sy1 = minimap.mapAPI:worldToUIY(y1)
    local sx2 = minimap.mapAPI:worldToUIX(x2)
    local sy2 = minimap.mapAPI:worldToUIY(y2)

    minimap:drawLine(sx1, sy1, sx2, sy2, col.r, col.g, col.b, col.a)
end

-----------------------            ---------------------------
function EnclosureChallenge.drawEnclosureGrid(midX, midY)
    if not ISWorldMap_instance then return end
    local mapAPI = ISWorldMap_instance.javaObject:getAPIv1()
    local symAPI = mapAPI:getSymbolsAPI()

    local size = EnclosureChallenge.EnclosureSize or 189
    local half = math.floor(size / 2)
    local x1 = midX - half
    local x2 = midX + half
    local y1 = midY - half
    local y2 = midY + half

    local tex = "X"
    local step = 3
    local alpha = 0.3

    local function addGridMark(x, y)
        local sym = symAPI:addTexture(tex, x, y)
        sym:setAnchor(0.5, 0.5)
        sym:setRGBA(0.8, 0.8, 0.2, alpha)
    end

    for x = x1, x2, step do
        addGridMark(x, y1)
        addGridMark(x, y2)
    end

    for y = y1 + step, y2 - step, step do
        addGridMark(x1, y)
        addGridMark(x2, y)
    end
end







--[[
function EnclosureChallenge.delChallengeSymbols(x, y)
    if not ISWorldMap_instance or not ISWorldMap_instance.javaObject then return end

    local pl = getPlayer()
    local size = EnclosureChallenge.EnclosureSize
    local data = EnclosureChallenge.getData()
    local ec = data.EnclosureChallenge
    if not ec then return end

    local reboundX = ec.Rebound.x or math.floor(pl:getX())
    local reboundY = ec.Rebound.y or math.floor(pl:getY())

    local edgeSquares = EnclosureChallenge.getEnclosurEdgeSquares(pl)

    local mapAPI = ISWorldMap_instance.javaObject:getAPIv1()
    if not mapAPI then return end
    local symAPI = mapAPI:getSymbolsAPI()
    if not symAPI then return end

    local targetSquares = {}
    for _, sq in ipairs(edgeSquares) do
        targetSquares[tostring(sq.x) .. "_" .. tostring(sq.y)] = true
    end
    targetSquares[tostring(reboundX) .. "_" .. tostring(reboundY)] = true

    for i = symAPI:getSymbolCount() - 1, 0, -1 do
        local sym = symAPI:getSymbolByIndex(i)
        local sx, sy = sym:getWorldX(), sym:getWorldY()
        if targetSquares[sx .. "_" .. sy] then
            symAPI:removeSymbolByIndex(i)
        end
    end
end
 ]]