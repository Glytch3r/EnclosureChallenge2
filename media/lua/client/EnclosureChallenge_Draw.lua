--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

require "lua_timers"

EnclosureChallenge = EnclosureChallenge or {}

-----------------------    keys*         ---------------------------

EnclosureChallenge.posGUI = EnclosureChallenge.posGUI or 1
EnclosureChallenge.alphaGUI = EnclosureChallenge.alphaGUI or 1
EnclosureChallenge.MouseTip = EnclosureChallenge.MouseTip or true

EnclosureChallenge.posTab = {
    "Position: Screen Percent",
    "Position: Center Screen",
    "Position: Off Center",
    "Position: Pixel Based",
    "Position: BottomRight",
    "Position: Preset",
}


function EnclosureChallenge.toPercent(val)
    return math.floor((val or 0) * 100 + 0.5)
end


function EnclosureChallenge.toggle(key)
    if not isIngameState() then return end

    local core = getCore()
    local msg

    if key == core:getKey("Toggle_Enclosure_MouseTip") then
        EnclosureChallenge.MouseTip = not EnclosureChallenge.MouseTip
        msg = "Enclosure Mouse ToolTip: " .. (EnclosureChallenge.MouseTip and "On" or "Off")

    elseif key == core:getKey("Adjust_Enclosure_GUI_Opacity") then
        EnclosureChallenge.alphaGUI = EnclosureChallenge.alphaGUI + 0.2
        if EnclosureChallenge.alphaGUI > 1 then
            EnclosureChallenge.alphaGUI = 0
        end
        msg = "Enclosure GUI Opacity: " .. EnclosureChallenge.toPercent(EnclosureChallenge.alphaGUI)

    elseif key == core:getKey("Adjust_Enclosure_GUI_Position") then
        EnclosureChallenge.posGUI = (EnclosureChallenge.posGUI % #EnclosureChallenge.posTab) + 1
        msg = EnclosureChallenge.posTab[EnclosureChallenge.posGUI] or "Invalid GUI Position"
    end

    if msg then
        getPlayer():setHaloNote(msg, 255, 250, 255, 255)
    end

    return key
end

Events.OnKeyPressed.Add(EnclosureChallenge.toggle)

-----------------------            ---------------------------

function EnclosureChallenge.getPointer()
    if not isIngameState() then return nil end
    local pl = getPlayer()
    if not pl then return nil end

    local z = pl:getZ()
    local x, y = ISCoordConversion.ToWorld(getMouseXScaled(), getMouseYScaled(), z)
    if not x or not y then return nil end
    return getCell():getOrCreateGridSquare(math.floor(x), math.floor(y), z)
end
-----------------------     mouse*       ---------------------------

function EnclosureChallenge.DrawMouseTip(x, y, z, str, r, g, b)
    if not isIngameState() then return end
    local tag = TextDrawObject.new()


    if not EnclosureChallenge.isActive then
        EnclosureChallenge.isActive = true

        tag:setDefaultFont(UIFont.Small)
        tag:ReadString(UIFont.Small, str, -1)
        tag:setDefaultColors(r, g, b)
        tag:setVisibleRadius(360)


        local yOffset = SandboxVars.EnclosureChallengeGUI.yMouseOffset or 0
        local xOffset = SandboxVars.EnclosureChallengeGUI.xMouseOffset or 0
        local function drawFunc()
            if not EnclosureChallenge.MouseTip then
                Events.OnPostRender.Remove(drawFunc)
                return
            end
            local zoom = getCore():getZoom(0)
            local screenX = (IsoUtils.XToScreen(x + xOffset, y, z, 0) - IsoCamera.getOffX()) / zoom
            local screenY = (IsoUtils.YToScreen(x + yOffset, y, z, 0) - IsoCamera.getOffY()) / zoom
            if EnclosureChallenge.MouseTip then tag:AddBatchedDraw(screenX, screenY-48, r,g,b,1, false) end
        end
        if EnclosureChallenge.checkMark ~= nil then
            EnclosureChallenge.checkMark:remove()
            EnclosureChallenge.checkMark = nil
        end
        if EnclosureChallenge.checkMark == nil then
            local markerSize = 0.3
            local sq = getCell():getOrCreateGridSquare(x, y, z)
            if sq then
                local stamp = "EnclosureChallenge_Bounds"



                if EnclosureChallenge.isOutOfBounds(sq) then
                    stamp = "EnclosureChallenge_Challenger"
                    markerSize = 2

                    local col = EnclosureChallenge.parseColor(SandboxVars.EnclosureChallengeGUI.BadColor)
                    r = col.r
                    g = col.g
                    b = col.b


                elseif EnclosureChallenge.isReboundSq(sq) then
                    markerSize = 2
                    stamp = "EnclosureChallenge_Circle"
                elseif EnclosureChallenge.isConquered(sq) then
                    markerSize = 1
                    stamp = "EnclosureChallenge_Conquered"

                    local col = EnclosureChallenge.parseColor(SandboxVars.EnclosureChallengeGUI.GoodColor)
                    r = col.r
                    g = col.g
                    b = col.b
                end

                if EnclosureChallenge.MouseTip then
                    EnclosureChallenge.checkMark = getWorldMarkers():addGridSquareMarker(stamp, stamp, sq, r, g, b, false, markerSize)
                end
            end
        end
        Events.OnPostRender.Add(drawFunc)

        timer:Simple(0.1, function()
            EnclosureChallenge.isActive = nil
            Events.OnPostRender.Remove(drawFunc)
        end)
    end
end


function EnclosureChallenge.MouseTipHandler(pl)
    if not isIngameState() then return end


    if not EnclosureChallenge.MouseTip then return end
    local sq = EnclosureChallenge.getPointer() or pl:getCurrentSquare()
    if not sq then return end
    local x, y, z = sq:getX(), sq:getY(), sq:getZ()
    if not (x and y and z) then return end


    local status = EnclosureChallenge.getChallengeStatus(sq) or ""

    if not EnclosureChallenge.isSameEnclosure(sq) then
        status = EnclosureChallenge.getEnclosureStatus(sq) or ""
    end

    local col = EnclosureChallenge.getEnclosureColor(sq)
    local encStr = EnclosureChallenge.getEnclosureStr(sq)

    local info = string.format("%d : %d\nEnclosure: %s\n%s", x, y, tostring(encStr), tostring(status))

    local reboundSq = EnclosureChallenge.getReboundSq()

    if reboundSq and reboundSq == sq then
        info = "RETURN POINT\n" .. info
    elseif EnclosureChallenge.isOutOfBounds(sq) then
        info = "OUT OF BOUNDS!\n" .. info
    end

    EnclosureChallenge.DrawMouseTip(x, y, z, info, col.r, col.g, col.b)
end
Events.OnPlayerUpdate.Add(EnclosureChallenge.MouseTipHandler)
-----------------------            ---------------------------

-----------------------            ---------------------------
EnclosureChallenge.guiTicks = 0

function EnclosureChallenge.GUI()
    if not isIngameState() then return end

    EnclosureChallenge.guiTicks = EnclosureChallenge.guiTicks + 1
    local isCacheFrame = (EnclosureChallenge.guiTicks % 30 == 0)

    local pl = getPlayer()
    if not pl then return end

    local isChallenger = EnclosureChallenge.isChallenger(pl)
    local isRemoteMode = EnclosureChallenge.isRemoteMode()

    EnclosureChallenge.cache = EnclosureChallenge.cache or {}
    local cache = EnclosureChallenge.cache

    if not isCacheFrame and cache.xPos then
        if isChallenger and cache.headerStr and cache.timeSize then
            getTextManager():DrawString(cache.timeSize, cache.xPos, cache.yPos - cache.textGap, cache.headerStr, 1, 0, 0, cache.alpha)
        end
        getTextManager():DrawString(cache.fSize, cache.xPos, cache.yPos, table.concat(cache.encInfo, '\n'), cache.col.r, cache.col.g, cache.col.b, cache.alpha)
        return
    end

    local xPercentPos = SandboxVars.EnclosureChallengeGUI.xPercentPos or 4
    local yPercentPos = SandboxVars.EnclosureChallengeGUI.yPercentPos or 55
    local xOffset = SandboxVars.EnclosureChallengeGUI.xOffset or 50
    local yOffset = SandboxVars.EnclosureChallengeGUI.yOffset or 50
    local textGap = SandboxVars.EnclosureChallengeGUI.textGap or 42
    local scrW = getCore():getScreenWidth()
    local scrH = getCore():getScreenHeight()

    local pos = EnclosureChallenge.posGUI
    local xPos, yPos
    if pos == 6 then
        xPos = (scrW / 8) + 55
        yPos = (scrH / 2) + 24
    elseif pos == 5 then
        xPos = scrW - xOffset
        yPos = scrH - yOffset
    elseif pos == 4 then
        xPos = xOffset
        yPos = yOffset
    elseif pos == 3 then
        xPos = (scrW / 2) + xOffset
        yPos = (scrH / 2) + yOffset
    elseif pos == 2 then
        xPos = scrW / 2
        yPos = scrH / 2
    else
        xPos = math.floor((xPercentPos / 100) * scrW)
        yPos = math.floor((yPercentPos / 100) * scrH)
    end

    local sq = pl:getCurrentSquare()
    if not sq then return end
    local x, y, z = sq:getX(), sq:getY(), sq:getZ()
    if not (x and y and z) then return end

    local encStr = EnclosureChallenge.getEnclosureStr(sq)
    local status = EnclosureChallenge.getEnclosureStatus(pl)
    local isOutOfBounds = EnclosureChallenge.isOutOfBounds(pl)
    local col = EnclosureChallenge.getEnclosureColor(pl)
    local alpha = EnclosureChallenge.alphaGUI

    if isOutOfBounds and isChallenger then
        col = EnclosureChallenge.parseColor(SandboxVars.EnclosureChallengeGUI.BadColor)
    end

    local ec = EnclosureChallenge.getData()
    if not ec then
        EnclosureChallenge.initChallengeData(pl)
        ec = EnclosureChallenge.getData()
    end

    local fontSizes = {
        [1] = UIFont.Small,
        [2] = UIFont.Medium,
        [3] = UIFont.Large,
    }
    local timeSizes = {
        [1] = UIFont.Medium,
        [2] = UIFont.Large,
        [3] = UIFont.NewLarge,
    }

    local optSizes = tonumber(SandboxVars.EnclosureChallengeGUI.FontSize) or 1
    local fSize = fontSizes[optSizes] or UIFont.Small
    local timeSize = timeSizes[optSizes] or UIFont.Medium

    local headerStr = ""
    if isChallenger then
        local modeStr = isRemoteMode and "Remote Mode" or "Additive Mode"
        local timeStr = EnclosureChallenge.getTimeStr()
        headerStr = string.format("%s\n%s", modeStr, timeStr)
        status = ""
    end
    local caption = EnclosureChallenge.getEnclosureStatus2(pl)
    local encInfo = {
        string.format("X: %d   Y: %d", round(x), round(y)),
        "Enclosure:n"..tostring(encStr).."\n"..tostring(caption),
        "",
    }

    if ec then
        table.insert(encInfo, tostring(EnclosureChallenge.getChallengeCount()) .. " : Unlocked")
        table.insert(encInfo, tostring(ec.AdditiveWins) .. " :Additive Wins")
        table.insert(encInfo, tostring(EnclosureChallenge.getConqueredCount()) .. " : Remote Wins")

        table.insert(encInfo, tostring(ec.UnlockPoints) .. " :Unlock Points")
        table.insert(encInfo, "\nRewardChoice:\n" .. tostring(EnclosureChallenge.getRewardTitle(ec.RewardChoice)))


    else
        table.insert(encInfo, "\nNo Enclosure Data")
    end

    EnclosureChallenge.cache = {
        fSize = fSize,
        xPos = xPos,
        yPos = yPos,
        encInfo = encInfo,
        col = col,
        alpha = alpha,
        headerStr = headerStr,
        timeSize = timeSize,
        textGap = textGap,
    }

    if isChallenger then
        getTextManager():DrawString(timeSize, xPos, yPos - textGap, headerStr, 1, 0, 0, alpha)
    end
    getTextManager():DrawString(fSize, xPos, yPos, table.concat(encInfo, '\n'), col.r, col.g, col.b, alpha)
end

Events.OnPostUIDraw.Add(EnclosureChallenge.GUI)
