--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

require "lua_timers"

EnclosureChallenge = EnclosureChallenge or {}

-----------------------            ---------------------------
function EnclosureChallenge.setChallenge(isStart, isRemote)
	local pl = getPlayer(); if not pl then return end
	local ec = EnclosureChallenge.getData(); if not ec then return end

	if not isStart then
		ec.RemoteTime = 0
		Events.EveryHours.Remove(EnclosureChallenge.RemoteTimer)
		return
	end

	local encStr = EnclosureChallenge.getEnclosureStr(pl)
	if not encStr then return end

	EnclosureChallenge.storeRebound(pl)
	EnclosureChallenge.addChallengeSymbols(pl)

	if isRemote then
		ec.RemoteChallenge = encStr
		ec.RemoteTime = SandboxVars.EnclosureChallenge.ChallengeHours or 168
		ec.AdditiveChallenge = ""
		ec.AdditiveTime = 0
		ec.AdditiveWins = 0

		Events.EveryHours.Remove(EnclosureChallenge.AdditiveTimer)
		Events.EveryHours.Add(EnclosureChallenge.RemoteTimer)
	else
		ec.AdditiveChallenge = encStr
		ec.AdditiveTime = 0
		ec.AdditiveWins = ec.AdditiveWins or 0
		ec.RemoteChallenge = ""
		ec.RemoteTime = 0

		Events.EveryHours.Remove(EnclosureChallenge.RemoteTimer)
		Events.EveryHours.Add(EnclosureChallenge.AdditiveTimer)
	end
end

-----------------------            ---------------------------


function EnclosureChallenge.isChallenger()
    return (EnclosureChallenge.isRemoteMode() or EnclosureChallenge.isAdditiveMode())
end

function EnclosureChallenge.getAdditiveTime()
    local ec = EnclosureChallenge.getData()
    if not ec then return 0 end
    ec.AdditiveTime = ec.AdditiveTime or 0
    return ec.AdditiveTime
end

function EnclosureChallenge.getRemoteTime()
    local ec = EnclosureChallenge.getData()
    if not ec then return 0 end
    ec.RemoteTime = ec.RemoteTime or 0
    return ec.RemoteTime
end
function EnclosureChallenge.isAdditiveMode()
    local ec = EnclosureChallenge.getData()
    return ec and ec.AdditiveChallenge ~= ""
end

function EnclosureChallenge.isRemoteMode()
    local ec = EnclosureChallenge.getData()
    return ec and ec.RemoteChallenge ~= ""
end

function EnclosureChallenge.getModeStr()
    if EnclosureChallenge.isChallenger() then
        if EnclosureChallenge.isAdditiveMode() then return "Additive Mode" end
        if EnclosureChallenge.isRemoteMode() then return "Remote Mode" end
    end
    return ""
end


function EnclosureChallenge.getChallengeStatus(targ)
    if not isIngameState() then return "Neutral" end
    targ = targ or getPlayer()
    if not targ then return "Neutral" end

    if EnclosureChallenge.isChallenger() and EnclosureChallenge.isSameEnclosure(targ) then
        return EnclosureChallenge.getModeStr()
    end

    return EnclosureChallenge.getEnclosureStatus(targ)
end



function EnclosureChallenge.getAdditiveChallenge()
    local ec = EnclosureChallenge.getData()
    if not ec then return 0 end
    ec.AdditiveChallenge = ec.AdditiveChallenge or ""
    return ec.AdditiveChallenge
end

function EnclosureChallenge.getRemoteChallenge()
    local ec = EnclosureChallenge.getData()
    if not ec then return 0 end
    ec.RemoteChallenge = ec.RemoteChallenge or ""
    return ec.RemoteChallenge
end



-----------------------            ---------------------------


function EnclosureChallenge.getChallenges()
    local ec = EnclosureChallenge.getData()
    if not ec then return nil end
    ec.Challenges = ec.Challenges or {}
    return ec.Challenges
end

function EnclosureChallenge.isConquered(targ)
	local ec = EnclosureChallenge.getData()
	ec.Conquered = ec.Conquered or {}

	local encStr = EnclosureChallenge.getEnclosureStr(targ)
	if not encStr then return false end

	return ec.Conquered[encStr] == true
end

function EnclosureChallenge.isUnlocked(targ)
    targ = targ or getPlayer()
    local ec = EnclosureChallenge.getData()
    ec.Challenges = ec.Challenges or {}

    local encStr = EnclosureChallenge.getEnclosureStr(targ)
    if not encStr then return false end

    return ec.Challenges[encStr] == true
end
-----------------------            ---------------------------
function EnclosureChallenge.isCanUnlock(targ)
    local pl = getPlayer()
    if EnclosureChallenge.isRemoteMode() then return false end
    --if EnclosureChallenge.isChallenger() then return false end
    --if not EnclosureChallenge.isUnlocked(targ) and not EnclosureChallenge.isConquered(targ) then
    if not EnclosureChallenge.isUnlocked(targ) then
        local ec = EnclosureChallenge.getData()
        if not ec or not ec.UnlockPoints then return false end
        return ec.UnlockPoints > 0
    end
    return false
end
-----------------------            ---------------------------
-----------------------            ---------------------------
function EnclosureChallenge.storeEnclosure(encStr)
    local ec = EnclosureChallenge.getData()

    if ec then
        ec.Challenges = ec.Challenges or {}
        ec.Challenges[encStr] = true
        print("Enclosure stored successfully")
    end
end

function EnclosureChallenge.getChallengeCount()
    local ec = EnclosureChallenge.getData()
    local tab = ec and ec.Challenges
    if not tab then return 0 end
    local count = 0
    for _ in pairs(tab) do
        count = count + 1
    end
    return count
end

-----------------------            ---------------------------
function EnclosureChallenge.doUnlock(targ)
    local pl = getPlayer()
    targ = targ or pl

    if not EnclosureChallenge.isCanUnlock(targ) then return false end

	local encStr = EnclosureChallenge.getEnclosureStr(targ)

    local ec = EnclosureChallenge.getData()
    if not ec or not ec.UnlockPoints or ec.UnlockPoints <= 0 then
        print("err not enough points")
        return false
    end

    ec.UnlockPoints = ec.UnlockPoints - 1
    HaloTextHelper.addTextWithArrow(pl, "Unlock Points - 1", false, HaloTextHelper.getColorRed())
    pl:playSound("GarageDoorUnlock")

    EnclosureChallenge.storeEnclosure(encStr)

    EnclosureChallenge.addChallengeSymbols(targ)
    return true
end

-----------------------            ---------------------------

function EnclosureChallenge.storeConquered(encStr)
    local pl = getPlayer(); if not pl then return false end
    local ec = EnclosureChallenge.getData()
    if not ec then return false end
    if encStr then
        local rebound = ec.Rebound
        --ec.RemoteWins = (ec.RemoteWins or 0) + 1

        if  rebound  then
            local x, y, z = rebound.x, rebound.y, rebound.z
            encStr = tostring(ec.RemoteChallenge) or EnclosureChallenge.getEnclosureStrXY(x, y) or EnclosureChallenge.getEnclosureStr(pl)


            local sq = getCell():getOrCreateGridSquare(x, y, z)
            if sq then EnclosureChallenge.addChallengeSymbols(sq) end
            HaloTextHelper.addTextWithArrow(pl, "Remote Wins + 1", true, HaloTextHelper.getColorGreen())

            ec.Conquered = ec.Conquered or {}
            ec.Conquered[encStr] = true


        end


    end



    return true
end

function EnclosureChallenge.getConqueredCount()
    local ec = EnclosureChallenge.getData()
    local tab = ec and ec.Conquered
    if not tab then return 0 end
    local count = 0
    for _ in pairs(tab) do
        count = count + 1
    end
    return count
end
