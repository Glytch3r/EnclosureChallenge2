--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

--EnclosureChallenge_Remote.lua
EnclosureChallenge = EnclosureChallenge or {}
-----------------------   remote challenge        ---------------------------

function EnclosureChallenge.goBack()
	local pl = getPlayer()

    EnclosureChallenge.clearCoord()
	local ec = EnclosureChallenge.getData()
	if not ec then return end
	local p = ec.OriginCoords
    if not pl then return end
    print('goBack() '..tostring(tostring(p.x).." "..tostring( p.y )))
	if p and p.x and p.y and p.z then
		EnclosureChallenge.tp(pl, p.x, p.y, p.z)
		--EnclosureChallenge.clearCoord()
	end
end


function EnclosureChallenge.clearCoord()
	local pl = getPlayer()
	if not pl then return end
	local ec = EnclosureChallenge.getData()
	if not ec then return end
	ec.OriginCoords = nil
end

function EnclosureChallenge.saveCoord()
    local pl = getPlayer()
    if not pl then return end
	local ec = EnclosureChallenge.getData()
    print("saveCoord()")
    if not ec then return end

    ec.OriginCoords = {x= round(pl:getX()), y = round(pl:getY()), z= pl:getZ()}
end
--[[  ]]-----------------------            ---------------------------
function EnclosureChallenge.isValidSq(sq)
    sq = sq or getPlayer():getCurrentSquare()
    if EnclosureChallenge.isConquered(sq) then return false end
    return sq and sq:connectedWithFloor() and sq:getFloor() ~= nil
end

function EnclosureChallenge.getEnclosureMidXY(x, y, targ)
    local size = EnclosureChallenge.EnclosureSize
    local pl = getPlayer()
    if pl then
        x = x or pl:getX()
        y = y or pl:getY()
    end
    if targ and targ ~= pl then
        x = targ:getX()
        y = targ:getY()
    end
    if not x or not y then return nil end

    local encX = math.floor(x / size)
    local midX = encX * size + math.floor(size / 2)

    local encY = math.floor(y / size)
    local midY = encY * size + math.floor(size / 2)

    return midX, midY
end

function EnclosureChallenge.getRandMidCoord()
    local size = EnclosureChallenge.EnclosureSize or 189

    if not ISWorldMap_instance then
        ISWorldMap.ShowWorldMap(0)
        if not ISWorldMap_instance then return nil, nil, nil, nil end
        ISWorldMap_instance:close()
    end

    local mapAPI = ISWorldMap_instance.javaObject and ISWorldMap_instance.javaObject:getAPIv1()
    if not mapAPI then return nil, nil, nil, nil end

    local maxX = mapAPI:getWidthInSquares() - 1
    local maxY = mapAPI:getHeightInSquares() - 1

    local boundLimitX = math.max(0, maxX - size)
    local boundLimitY = math.max(0, maxY - size)

    if boundLimitX == 0 or boundLimitY == 0 then
        return nil, nil, nil, nil
    end

    local EnclosureX = ZombRand(0, boundLimitX + 1)
    local EnclosureY = ZombRand(0, boundLimitY + 1)

    local midX, midY = EnclosureChallenge.getEnclosureMidXY(EnclosureX, EnclosureY)
    return midX, midY, EnclosureX, EnclosureY
end

function EnclosureChallenge.tpRandMidSq()
    local pl = getPlayer()


    --if EnclosureChallenge.isChallenger() then return end
	--EnclosureChallenge.clearCoord()

    local rTick = 0
    local waitTicks = 60
    local maxTicks = 300
    local maxAttempts = math.floor(maxTicks / waitTicks)
    local attemptCount = 0

    local midX, midY, enclosureX, enclosureY = EnclosureChallenge.getRandMidCoord()
    if not midX then
        pl:Say("Map API failed.")
        return
    end

    EnclosureChallenge.tp(pl, midX, midY)

    local function tpHandler()
        rTick = rTick + 1
        if rTick % waitTicks == 0 then
            local sq = pl:getSquare()
            if not EnclosureChallenge.isValidSq(sq) then
                attemptCount = attemptCount + 1
                if attemptCount >= maxAttempts then
                    pl:Say("Unable to find valid location.")
                    EnclosureChallenge.goBack()
                    Events.OnTick.Remove(tpHandler)
                    return
                end
                midX, midY, enclosureX, enclosureY = EnclosureChallenge.getRandMidCoord()
                if not midX then
                    pl:Say("Retry failed.")
                    Events.OnTick.Remove(tpHandler)
                    return
                end
                EnclosureChallenge.tp(pl, midX, midY)
                rTick = 0
                return
            end

            EnclosureChallenge.ConfirmDialog(pl, "Accept Remote Challenge?", "Enclosure Challenge", false, true)
            Events.OnTick.Remove(tpHandler)
        end
    end

    Events.OnTick.Add(tpHandler)
end
