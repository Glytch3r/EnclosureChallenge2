--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

--EnclosureChallenge_Remote.lua

EnclosureChallenge = EnclosureChallenge or {}
-----------------------   remote challenge        ---------------------------
function EnclosureChallenge.goBack()
    local pl = getPlayer()
    if not pl then return end

    local x, y, z = EnclosureChallenge.getCoords()
    if x and y and z then
        print("goBack() to:".. tostring(x)..", ".. tostring(y)..", ".. tostring(z))
        EnclosureChallenge.tp(pl, x, y, z)
    end

    EnclosureChallenge.clearCoord()
end

function EnclosureChallenge.clearCoord()
    local ec = EnclosureChallenge.getData()
    if ec then
        ec.OriginCoords = {}
    end
end

function EnclosureChallenge.saveCoord()
    local pl = getPlayer()
    if not pl then return end

    local csq = pl:getCurrentSquare()
    if not csq then return end

    local ec = EnclosureChallenge.getData()
    if ec then
        if ec.OriginCoords  and ec.OriginCoords.x == nil and ec.OriginCoords.y == nil then
            ec.OriginCoords = {
                x = round(csq:getX()),
                y = round(csq:getY()),
                z = csq:getZ()
            }
        end
        print("saveCoord()"..tostring(ec.OriginCoords.x)..",  "..tostring(ec.OriginCoords.y))

    end
end
function EnclosureChallenge.getCoords()
    local ec = EnclosureChallenge.getData()
    ec.OriginCoords = ec.OriginCoords or {}
    if ec and ec.OriginCoords then
        return ec.OriginCoords.x, ec.OriginCoords.y, ec.OriginCoords.z
    end
    return nil, nil, nil
end
-----------------------            ---------------------------

function EnclosureChallenge.isValidSq(sq)
    sq = sq or getPlayer():getCurrentSquare()
    if EnclosureChallenge.isConquered(sq) then return false end
    return sq and sq:connectedWithFloor() and sq:getFloor() ~= nil
end

-----------------------            ---------------------------
function EnclosureChallenge.getEnclosureMidXY(x, y, targ)
    local size = EnclosureChallenge.EnclosureSize or 189
    local pl = getPlayer()

    if pl then
        x = x or pl:getX()
        y = y or pl:getY()
    end
    if targ and targ ~= pl then
        x = targ:getX()
        y = targ:getY()
    end
    if not x or not y then return nil end

    local encX = math.floor(x / size)
    local midX = encX * size + math.floor(size / 2)

    local encY = math.floor(y / size)
    local midY = encY * size + math.floor(size / 2)

    return midX, midY
end

function EnclosureChallenge.getRandMidCoord()
    local size = EnclosureChallenge.EnclosureSize or 189

    if not ISWorldMap_instance then
        ISWorldMap.ShowWorldMap(0)
        return nil, nil, nil, nil
    end

    local mapAPI = ISWorldMap_instance.javaObject and ISWorldMap_instance.javaObject:getAPIv1()
    if not mapAPI then return nil, nil, nil, nil end

    local maxX = mapAPI:getWidthInSquares() - 1
    local maxY = mapAPI:getHeightInSquares() - 1

    local boundLimitX = math.max(0, maxX - size)
    local boundLimitY = math.max(0, maxY - size)

    if boundLimitX == 0 or boundLimitY == 0 then
        return nil, nil, nil, nil
    end

    local EnclosureX = ZombRand(0, boundLimitX + 1)
    local EnclosureY = ZombRand(0, boundLimitY + 1)

    local midX, midY = EnclosureChallenge.getEnclosureMidXY(EnclosureX, EnclosureY)
    return midX, midY, EnclosureX, EnclosureY
end

function EnclosureChallenge.tpRandMidSq()
    local pl = getPlayer()
    if not pl then return end

    local rTick = 0
    local waitTicks = 60
    local maxTicks = 300
    local maxAttempts = math.floor(maxTicks / waitTicks)
    local attemptCount = 0

    local midX, midY, enclosureX, enclosureY = EnclosureChallenge.getRandMidCoord()
    if not midX then
        pl:Say("Map API failed.")
        return
    end


    EnclosureChallenge.tp(pl, midX, midY)

    local function tpHandler()
        rTick = rTick + 1
        if rTick % waitTicks == 0 then
            local sq = pl:getSquare()
            if not EnclosureChallenge.isValidSq(sq) then
                attemptCount = attemptCount + 1
                if attemptCount >= maxAttempts then
                    pl:Say("Unable to find valid location.")
                    EnclosureChallenge.goBack()
                    Events.OnTick.Remove(tpHandler)
                    return
                end

                midX, midY, enclosureX, enclosureY = EnclosureChallenge.getRandMidCoord()
                if not midX then
                    pl:Say("Retry failed.")
                    Events.OnTick.Remove(tpHandler)
                    return
                end

                EnclosureChallenge.tp(pl, midX, midY)
                rTick = 0
                return
            end

            EnclosureChallenge.ConfirmDialog(pl, "Accept Remote Challenge?", "Enclosure Challenge", false, true)
            Events.OnTick.Remove(tpHandler)
        end
    end

    Events.OnTick.Add(tpHandler)
end