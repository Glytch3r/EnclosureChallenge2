
--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

EnclosureChallenge = EnclosureChallenge or {}
-----------------------  challenge out of bound  tp* bounds*      ---------------------------

function EnclosureChallenge.isOutOfBounds(targ)
	if not isIngameState() or not targ then return false end

	local pl = getPlayer()
	if not pl:isAlive() or not EnclosureChallenge.isChallenger() then return false end

	local encStr = EnclosureChallenge.getEnclosureStr(targ)
	if not encStr then return false end

	local ec = EnclosureChallenge.getData()
	if not ec then return false end

	if EnclosureChallenge.isRemoteMode() then
		return tostring(encStr) ~= tostring(ec.RemoteChallenge)

	elseif EnclosureChallenge.isAdditiveMode() then
		local csq = pl:getCurrentSquare()
		if csq then
			if EnclosureChallenge.isUnlocked(csq) or EnclosureChallenge.getEnclosureStatus(csq) == "Unlocked" then
				return false
			end
		end
		ec.Challenges = ec.Challenges or {}
		return not ec.Challenges[encStr]
	end

	return false
end



function EnclosureChallenge.isSameEnclosure(targ)
	local pl = getPlayer()
	targ = targ or EnclosureChallenge.getPointer()
	if not targ then return false end

	local plEncStr = EnclosureChallenge.getEnclosureStr(pl)
	local targEncStr = EnclosureChallenge.getEnclosureStr(targ)
	if not plEncStr or not targEncStr then return false end

	return plEncStr == targEncStr
end

-----------------------    tp*        ---------------------------
function EnclosureChallenge.rebound()
    local pl = getPlayer()
	local ec = EnclosureChallenge.getData()

	local p = ec.Rebound
	if p and p.x and p.y and p.z then
		EnclosureChallenge.tp(pl, p.x, p.y, p.z)
	end
end
-----------------------      rebound*      ---------------------------


function EnclosureChallenge.isRebound(sq)
	if not sq then return false end
	local x, y = math.floor(sq:getX()), math.floor(sq:getY())
	local rx, ry = EnclosureChallenge.getRebound()
	return rx and ry and x == math.floor(rx) and y == math.floor(ry)
end

function EnclosureChallenge.isReboundSq(sq)
	if not sq then return false end
	return EnclosureChallenge.getReboundSq() == sq
end

function EnclosureChallenge.getRebound()
	local ec = EnclosureChallenge.getData()
	if not ec or not ec.Rebound then return nil end
	return ec.Rebound.x, ec.Rebound.y, ec.Rebound.z or 0
end

function EnclosureChallenge.getReboundSq()
	local x, y, z = EnclosureChallenge.getRebound()
	if not x or not y then return nil end
	return getCell():getOrCreateGridSquare(x, y, z or 0)
end
-----------------------            ---------------------------


-----------------------            ---------------------------
EnclosureChallenge.Rebound = setmetatable({}, {
    __index = {
        tick = 0,
        pl = nil,
        staggered = false,
        inTransit = false,

        reset = function(self)
            self.tick = 0
            self.pl = nil
            self.staggered = false
            self.inTransit = false
        end,

        start = function(self, player)
            if self.inTransit then return end
            self.inTransit = true

            player = player or getPlayer()
            local ec = player:getModData().EnclosureChallenge
            if not ec or not ec.Rebound then
                self:reset()
                return
            end

            local x, y, z = ec.Rebound.x, ec.Rebound.y, ec.Rebound.z or 0
            if not (x and y) then
                self:reset()
                return
            end

            if isClient() then
                sendClientCommand("EnclosureChallenge", "send", {})
            else
                EnclosureChallenge.tp(player, x, y, z)
            end

            self.pl = player
            self.tick = 0
            self.staggered = false

            if SandboxVars.EnclosureChallenge.ReturnStaggered then
                Events.OnTick.Add(self.handler)
            else
                self:reset()
            end
        end,

        handler = function()
            local rebound = EnclosureChallenge.Rebound
            local pl = getPlayer()
            if not pl then
                Events.OnTick.Remove(rebound.handler)
                return
            end

            rebound.tick = rebound.tick + 1
            local csq = pl:getCurrentSquare()

            if rebound.tick % 4 == 0 or (csq and EnclosureChallenge.isReboundSq(csq)) then
                if not rebound.staggered and rebound.pl then
                    rebound.staggered = true

                    if isClient() then
                        sendClientCommand("EnclosureChallenge", "stagger", {})
                    else
                        EnclosureChallenge.stag(pl)
                    end

                    Events.OnTick.Remove(rebound.handler)
                    rebound:reset()
                end
            end
        end
    }
})

-----------------------            ---------------------------
--[[

function EnclosureChallenge.rebound()
    if EnclosureChallenge.isInTransit then return end
    EnclosureChallenge.isInTransit = true

    pl = pl or getPlayer()
    local ec = pl:getModData().EnclosureChallenge
    if not ec or not ec.Rebound then
        EnclosureChallenge.isInTransit = false
        return
    end

    local x, y, z = ec.Rebound.x, ec.Rebound.y, ec.Rebound.z
    if not (x and y) then
        EnclosureChallenge.isInTransit = false
        return
    end

    if isClient() then
        sendClientCommand("EnclosureChallenge", "send", {})
    else
        EnclosureChallenge.tp(pl, x, y, z)
    end

    local state = EnclosureChallenge.reboundState
    state.staggered = false
    state.bTick = 0
    state.reboundPl = pl

    if SandboxVars.EnclosureChallenge.ReturnStaggered then
        Events.OnTick.Add(EnclosureChallenge.reboundHandler)
    else
        EnclosureChallenge.isInTransit = false
        state.reboundPl = nil
    end
end

 ]]
--[[
if not getVariableBoolean("BumpStaggered") then
    return
end ]]

-----------------------    tp*        ---------------------------
--[[  function EnclosureChallenge.rebo     und(pl)
    pl = pl or getPlayer()
    local data = pl:getModData()
    if not data then return end
    local ec = data.EnclosureChallenge
    if not ec then return end
    local x = ec.Rebound.x
    local y = ec.Rebound.y
    local z = ec.Rebound.z or 0
    if x and y then
        if isClient() then
            local teleportto = {x,y,z}
            SendCommandToServer(tostring("/teleportto \"".. teleportto[1]..','..teleportto[2]..','..teleportto[3]  .."\" " .. " \""))
        end
        pl:setHaloNote("OUT OF BOUNDS: " .. tostring(round(x)) .. "  " .. tostring(round(y)), 150, 250, 150, 300)
        --EnclosureChallenge.tp(pl, x, y, z)
    end
end
 ]]
