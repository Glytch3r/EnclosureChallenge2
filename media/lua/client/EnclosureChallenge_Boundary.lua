
--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

EnclosureChallenge = EnclosureChallenge or {}
-----------------------  challenge out of bound  tp* bounds*      ---------------------------

function EnclosureChallenge.isOutOfBounds(targ)
    local pl = getPlayer()
    targ = targ or pl
    if not targ then return false end
    if not EnclosureChallenge.isChallenger() then return false end

    local encStr = EnclosureChallenge.getEnclosureStr(targ)
    if not encStr then return false end


    local ec = EnclosureChallenge.getData()

    if EnclosureChallenge.isRemoteMode(pl) then
        return ec.RemoteChallenge ~= EnclosureChallenge.getEnclosureStr(pl:getCurrentSquare())
    else
        return not ec.Challenges[encStr]
    end

end



function EnclosureChallenge.isSameEnclosure(targ)
    local pl = getPlayer()
    targ = targ or EnclosureChallenge.getPointer()

    if not targ then return false end

    local plEncStr = EnclosureChallenge.getEnclosureStr(pl)
    if not plEncStr then return false end

    local targEncStr = EnclosureChallenge.getEnclosureStr(targ)
    if not targEncStr then return false end

    return plEncStr == targEncStr
end

-----------------------            ---------------------------
--[[
function EnclosureChallenge.OutOfBoundHandler(pl)
    pl = pl or getPlayer()
    if not EnclosureChallenge.isChallenger(pl) then return end
    local id = pl:getOnlineID() or 0
    playerTicks[id] = (playerTicks[id] or 0) + 1
    local tick = playerTicks[id] % 60

    if tick % 30 == 0 then
        if EnclosureChallenge.isOutOfBounds(pl) and pl:isAlive() then
            EnclosureChallenge.rebound(pl)
            pl:setHaloNote("OUT OF BOUNDS", 255, 50, 50, 150)
        end
    end

    if playerTicks[id] >= 60 then
        playerTicks[id] = 0
    end
end

Events.OnPlayerUpdate.Add(EnclosureChallenge.OutOfBoundHandler)
 ]]
-----------------------            ---------------------------
function EnclosureChallenge.isRebound(sq)
    if not sq then return false end

    local rebound = EnclosureChallenge.getRebound()
    if not rebound or not rebound.x or not rebound.y then return false end

    local x = math.floor(sq:getX())
    local y = math.floor(sq:getY())

    return x == math.floor(rebound.x) and y == math.floor(rebound.y)
end

function EnclosureChallenge.isReboundSq(sq)
    return EnclosureChallenge.getReboundSq() == sq
end

function EnclosureChallenge.getRebound()
    local ec = EnclosureChallenge.getData()
    if not ec or not ec.Rebound then return nil end

    return {
        x = ec.Rebound.x,
        y = ec.Rebound.y,
        z = ec.Rebound.z,
    }
end

function EnclosureChallenge.getReboundSq()
    local ec = EnclosureChallenge.getData()
    if not ec or not ec.Rebound then return nil end

    local x = ec.Rebound.x
    local y = ec.Rebound.y
    local z = ec.Rebound.z or 0

    if not x or not y then return nil end

    return getCell():getOrCreateGridSquare(x, y, z)
end

function EnclosureChallenge.clearRebound()
    local ec = EnclosureChallenge.getData()
    if not ec or not ec.Rebound then return end

    ec.Rebound = {}


    EnclosureChallenge.delReturnPointMarker()
end

function EnclosureChallenge.storeRebound(targ)
    targ = targ or getPlayer()
    if not targ then return end

    EnclosureChallenge.clearRebound()

    local ec = EnclosureChallenge.getData()
    if not ec then return end
    local encStr =  EnclosureChallenge.getEnclosureStr(targ)

    ec.Rebound = {
        x = round(targ:getX()),
        y = round(targ:getY()),
        z = targ:getZ() or 0,
    }
    EnclosureChallenge.setReturnPointMarker()



end

-----------------------            ---------------------------


-----------------------            ---------------------------
EnclosureChallenge.reboundState = {
    staggered = false,
    bTick = 0,
    reboundPl = nil,
}

function EnclosureChallenge.reboundHandler()

    local state = EnclosureChallenge.reboundState
    state.bTick = state.bTick + 1

    if state.bTick % 4 == 0 or EnclosureChallenge.isReboundSq(getPlayer():getCurrentSquare()) then
        if not state.staggered and state.reboundPl then
            state.staggered = true
            if isClient() then
                sendClientCommand("EnclosureChallenge", "stagger", {})
            else
                EnclosureChallenge.stag(state.reboundPl)
            end
            Events.OnTick.Remove(EnclosureChallenge.reboundHandler)
            EnclosureChallenge.isInTransit = false
            state.reboundPl = nil
        end
    end
end


function EnclosureChallenge.rebound(pl)
    if EnclosureChallenge.isInTransit then return end
    EnclosureChallenge.isInTransit = true

    pl = pl or getPlayer()
    local ec = pl:getModData().EnclosureChallenge
    if not ec or not ec.Rebound then
        EnclosureChallenge.isInTransit = false
        return
    end
    if isClient() then
        sendClientCommand("EnclosureChallenge", "send", {})
    else
        EnclosureChallenge.tp(pl, x, y, z)
    end

    local x, y, z = ec.Rebound.x, ec.Rebound.y, ec.Rebound.z or 0
    if not (x and y) then
        EnclosureChallenge.isInTransit = false
        return
    end

    local state = EnclosureChallenge.reboundState
    state.staggered = false
    state.bTick = 0
    state.reboundPl = pl
    if SandboxVars.EnclosureChallenge.ReturnStaggered then
        Events.OnTick.Add(EnclosureChallenge.reboundHandler)
    else
        EnclosureChallenge.isInTransit = false
        state.reboundPl = nil
    end


end

-----------------------    tp*        ---------------------------
--[[  function EnclosureChallenge.rebound(pl)
    pl = pl or getPlayer()
	local ec = pl:getModData().EnclosureChallenge
	local p = ec.Rebound
	if p and p.x and p.y and p.z then
		EnclosureChallenge.tp(pl, p.x, p.y, p.z)
	end
end ]]
-----------------------    tp*        ---------------------------
--[[  function EnclosureChallenge.rebo     und(pl)
    pl = pl or getPlayer()
    local data = pl:getModData()
    if not data then return end
    local ec = data.EnclosureChallenge
    if not ec then return end
    local x = ec.Rebound.x
    local y = ec.Rebound.y
    local z = ec.Rebound.z or 0
    if x and y then
        if isClient() then
            local teleportto = {x,y,z}
            SendCommandToServer(tostring("/teleportto \"".. teleportto[1]..','..teleportto[2]..','..teleportto[3]  .."\" " .. " \""))
        end
        pl:setHaloNote("OUT OF BOUNDS: " .. tostring(round(x)) .. "  " .. tostring(round(y)), 150, 250, 150, 300)
        --EnclosureChallenge.tp(pl, x, y, z)
    end
end
 ]]
