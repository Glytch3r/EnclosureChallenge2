--[[██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                        				 Custom  PZ  Mod  Developer  for  Hire													  |
|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
|                       	Portfolio:  https://steamcommunity.com/id/glytch3r/myworkshopfiles/							          |
|                       		                                    														 	  |
|                       	Discord:    Glytch3r#1337 / glytch3r															      |
|                       		                                    														 	  |
|                       	Support:    https://ko-fi.com/glytch3r														    	  |
|_______________________________________________________________________________________________________________________________-]]
--[[_____________________________________________________________________________________________________________________________
   ░▒▓██████▓▒░    ░▒▓████████▓▒░    ░▒▓█▓▒░         ░▒▓█▓▒░      ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░           ░▒▓█▓▒░         ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░  ░▒▓▒░
  ░▒▓█▓▒▒▓███▓▒░   ░▒▓█▓▒░         ░▒▓██████▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█████████▓▒░     ░▒▓███▓▒░     ░▒▓███████▓▒░
  ░▒▓█▓▒░          ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░         ░▒▓█▓▒░ ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
  ░▒▓█▓▒░░▒▓█▓▒░   ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░     ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░ ░▒▓█▓▒░  ▒▓░    ░▒▓█▓▒░   ░▒▓█▒░  ░▒▓█▒░
   ░▒▓█████▓▒░     ░▒▓█▓▒░        ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓███████▓▒░   ░▒▓██████▓▒░   ░▒▓█▓▒░ ░▒▓█▓▒░  ░▒▓███████▓▒░    ░▒▓███████▓▒░
█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████--]]

--EnclosureChallenge_Marker.lua
require "lua_timers"

EnclosureChallenge = EnclosureChallenge or {}


-----------------------            ---------------------------


EnclosureChallenge.markerTab = {
    ["Challenger"] = "EnclosureChallenge_Challenger",
    ["Conquered"] = "EnclosureChallenge_Conquered",
    ["Unlocked"] = "EnclosureChallenge_Unlocked",
    ["Neutral"] = "EnclosureChallenge_Neutral",
}

-----------------------            ---------------------------
function EnclosureChallenge.getEdgeMarkersForEnclosure(enc, targ)
    if not enc then return {} end
    local z = 0
    local edgeSet = {}
    local res = {}

    local edgeSquares = EnclosureChallenge.getEnclosurEdgeSquares(targ)
    for _, sq in ipairs(edgeSquares) do
        local key = string.format("%d_%d_%d", sq.x, sq.y, z)
        edgeSet[key] = true
    end

    for i = #EnclosureChallenge.edgeMarkers, 1, -1 do
        local marker = EnclosureChallenge.edgeMarkers[i]
        if marker then
            local msq = nil

            if type(marker) == "userdata" and marker.getSquare then
                msq = marker:getSquare()
            elseif type(marker) == "table" and marker.square then
                msq = marker.square
            end

            if msq then
                local key = string.format("%d_%d_%d", msq:getX(), msq:getY(), msq:getZ())
                if edgeSet[key] then
                    table.insert(res, marker)
                end
            end
        end
    end

    return res
end


function EnclosureChallenge.tableContains(tab, val)
    for _, v in ipairs(tab) do
        if v == val then return true end
    end
    return false
end

function EnclosureChallenge.setMarkers(targ, keepOld)
    local pl = getPlayer()
    targ = targ or pl
    if not pl then return end

    local enc = EnclosureChallenge.getEnclosure(targ)
    if not enc then return end

    EnclosureChallenge.edgeMarkers = EnclosureChallenge.edgeMarkers or {}
    if not keepOld then
        for i = #EnclosureChallenge.edgeMarkers, 1, -1 do
            local marker = EnclosureChallenge.edgeMarkers[i]
            if marker then marker:remove() end
            table.remove(EnclosureChallenge.edgeMarkers, i)
        end
    end

    local status = EnclosureChallenge.getEnclosureStatus(targ)
    local col = EnclosureChallenge.getEnclosureColor(targ)
    local r, g, b, a = col.r, col.g, col.b, col.a

    local stampMarkers = {
        ["Conquered"] = "EnclosureChallenge_Conquered",
        ["Unlocked"]  = "EnclosureChallenge_Unlocked",
        ["Neutral"]   = "EnclosureChallenge_Neutral",
    }
    local stamp = stampMarkers[status] or "EnclosureChallenge_Neutral"

    local isChallenger = EnclosureChallenge.isChallenger()

    if isChallenger then
        stamp = "EnclosureChallenge_Challenger"
    end

    local edgeSquares = EnclosureChallenge.getEnclosurEdgeSquares(targ)
    local wm = getWorldMarkers()
    if not wm then return end

    for _, eSq in ipairs(edgeSquares) do
        local sq = getCell():getOrCreateGridSquare(eSq.x, eSq.y, 0)
        if sq then
            local marker = wm:addGridSquareMarker(stamp, stamp, sq, r, g, b, true, isChallenger and 1 or 0.5)
            table.insert(EnclosureChallenge.edgeMarkers, marker)
        end
    end
end

-----------------------            ---------------------------



-----------------------            ---------------------------
function EnclosureChallenge.getEnclosureTexture(targ)
    return EnclosureChallenge.markerTab[EnclosureChallenge.getEnclosureStatus(targ)]
end
---------            ---------------------------

-----------------------            ---------------------------
function EnclosureChallenge.getEnclosurEdgeSquares(targ)
    local edgeSquares = {}
    local size = EnclosureChallenge.EnclosureSize
    local cellWidth = size
    local cellHeight = size
    targ = targ or getPlayer()
    local x = round(targ:getX())
    local y = round(targ:getY())
    local startX = math.floor(x / size) * size
    local startY = math.floor(y / size) * size

    for x = startX, startX + cellWidth - 1 do
        table.insert(edgeSquares, {x = x, y = startY})
        table.insert(edgeSquares, {x = x, y = startY + cellHeight - 1})
    end

    for y = startY + 1, startY + cellHeight - 2 do
        table.insert(edgeSquares, {x = startX, y = y})
        table.insert(edgeSquares, {x = startX + cellWidth - 1, y = y})
    end

    return edgeSquares
end

-----------------------            ---------------------------

function EnclosureChallenge.setReturnPointMarker()
    local pl = getPlayer()
    if not pl then return end
    local ec = EnclosureChallenge.getData()

    if ec.Rebound then
       -- local x, y, z =  ec.Rebound.x,   ec.Rebound.y,   ec.Rebound.z or 0


--[[         if not EnclosureChallenge.isChallenger() then
            EnclosureChallenge.clearRebound()
            return
        end
 ]]

        EnclosureChallenge.delReturnPointMarker()

        local col = EnclosureChallenge.parseColor(SandboxVars.EnclosureChallengeGUI.MarkerColor)
        local r, g, b, a = col.r, col.g, col.b, col.a

        local guideSq =  EnclosureChallenge.getReboundSq()
        if not guideSq then return end

        if SandboxVars.EnclosureChallenge.ShowArrowGuide then
            EnclosureChallenge.guide = getWorldMarkers():addPlayerHomingPoint(pl, x, y, "arrow_triangle", r, g, b, a, true, 5)
        end
        EnclosureChallenge.reboundMark = getWorldMarkers():addGridSquareMarker("EnclosureChallenge_Return", "EnclosureChallenge_Return", guideSq, r, g, b, true, 2)
    end
end


function EnclosureChallenge.delReturnPointMarker()
    if EnclosureChallenge.guide then
        EnclosureChallenge.guide:remove()
        EnclosureChallenge.guide = nil
    end
    if EnclosureChallenge.reboundMark then
        EnclosureChallenge.reboundMark:remove()
        EnclosureChallenge.reboundMark = nil
    end
end
